import UUIDs: uuid1

import TableIOInterface: get_example_code, is_extension_supported

"Will hold all 'response handlers': functions that respond to a WebSocket request from the client."
const responses = Dict{Symbol,Function}()

Base.@kwdef struct ClientRequest
    session::ServerSession
    notebook::Union{Nothing,Notebook}
    body::Any=nothing
    initiator::Union{Initiator,Nothing}=nothing
end

require_notebook(r::ClientRequest) = if r.notebook === nothing
    throw(ArgumentError("Notebook request called without a notebook ðŸ˜—"))
end


###
# RESPONDING TO A NOTEBOOK STATE UPDATE
###

"""
## State management in Pluto

*Aka: how do the server and clients stay in sync?*



A Pluto notebook session has *state*: with this, we mean:

1. The input and ouput of each cell, the cell order, and more metadata about the notebook and cells [^state]

This state needs to be **synchronised between the server and all clients** (we support multiple synchronised clients), and note that:

- Either side wants to update the state. Generally, a client will update cell inputs, the server will update cell outputs.
- Both sides want to *react* to state updates
- The server is in Julia, the clients are in JS
- This is built on top of our websocket+msgpack connection, but that doesn't matter too much

We do this by implementing something similar to how you use Google Firebase: there is **one shared state object, any party can mutate it, and it will synchronise to all others automatically**. The state object is a nested structure of mutable `Dict`s, with immutable ints, strings, bools, arrays, etc at the endpoints.



Some cool things are:

- Our system uses object diffing, so only *changes to the state* are actually tranferred over the network. But you can use it as if the entire state is sent around constantly.
- In the frontend, the *shared state* is part of the *react state*, i.e. shared state updates automatically trigger visual updates.
- Within the client, state changes take effect instantly, without waiting for a round trip to the server. This means that when you add a cell, it shows up instantly.

Diffing is done using `immer.js` (frontend) and `src/webserver/Firebasey.jl` (server). We wrote Firebasey ourselves to match immer's functionality, and the cool thing is: **it is a Pluto notebook**! Since Pluto notebooks are `.jl` files, we can just `include` it in our module.

The shared state object is generated by [`notebook_to_js`](@ref). Take a look! The Julia server orchestrates this firebasey stuff. For this, we keep a **copy** of the latest state of each client on the server (see [`current_state_for_clients`](@ref)). When anything changes to the Julia state (e.g. when a cell finished running), we call [`send_notebook_changes!`](@ref), which will call [`notebook_to_js`](@ref) to compute the new desired state object. For each client, we diff the new state to their last known state, and send them the difference.



### Responding to changes made by a client

When a client updates the shared state object, we want the server to *react* to that change by taking an action. Which action to take depends on which field changes. For example, when `state["path"]` changes, we should rename the notebook file. When `state["cell_inputs"][a_cell_id]["code"]` changes, we should reparse and analyze that cel, etc. This location of the change, e.g.  `"cell_inputs/<a_cell_id>/code"` is called the *path* of the change.

[`effects_of_changed_state`](@ref) define these pattern-matchers. We use a `Wildcard()` to take the place of *any* key, see [`Wildcard`](@ref), and we use the change/update/patch inside the given function.



### Not everything uses the shared state (yet)

Besides `:update_notebook`, you will find more functions in [`responses`](@ref) that respond to classic 'client requests', such as `:reshow_cell` and `:shutdown_notebook`. Some of these requests get a direct response, like the list of autocomplete options to a `:complete` request (in `src/webserver/REPLTools.jl`). On the javascript side, these direct responses can be `awaited`, because every message has a unique ID.



[^state]:
    Two other meanings of _state_ could be:
    2. The reactivity data: the parsed AST (`Expr`) of each cell, which variables are defined or referenced by which cells, in what order will cells run?
    3. The state of the Julia process: i.e. which variables are defined, which packages are imported, etc.
    
    The first two (1 & 2) are stored in a [`Notebook`](@ref) struct, remembered by the server process (Julia). (In fact, (2) is entirely described by (1), but we store it for performance reasons.) I included (3) for completeness, but it is not stored by us, we hope to control and minimize (3) by keeping track of (1) and (2).

"""
module Firebasey include("./Firebasey.jl") end

# All of the arrays in the notebook_to_js object are 'immutable' (we write code as if they are), so we can enable this optimization:
Firebasey.use_triple_equals_for_arrays[] = true

# the only possible Arrays are:
# - cell_order
# - cell_result > * > output > body
# - bonds > * > value > *

function notebook_to_js(notebook::Notebook)
    Dict{String,Any}(
        "notebook_id" => notebook.notebook_id,
        "path" => notebook.path,
        "in_temp_dir" => startswith(notebook.path, new_notebooks_directory()),
        "shortpath" => basename(notebook.path),
        "process_status" => notebook.process_status,
        "cell_inputs" => Dict{UUID,Dict{String,Any}}(
            id => Dict{String,Any}(
                "cell_id" => cell.cell_id,
                "code" => cell.code,
                "code_folded" => cell.code_folded,
            )
        for (id, cell) in notebook.cells_dict),
        "cell_results" => Dict{UUID,Dict{String,Any}}(
            id => Dict{String,Any}(
                "cell_id" => cell.cell_id,
                "output" => Dict(                
                    "body" => cell.output.body,
                    "mime" => cell.output.mime,
                    "rootassignee" => cell.output.rootassignee,
                    "last_run_timestamp" => cell.output.last_run_timestamp,
                    "persist_js_state" => cell.output.persist_js_state,
                ),
                "queued" => cell.queued,
                "running" => cell.running,
                "errored" => cell.errored,
                "runtime" => cell.runtime,
            )
        for (id, cell) in notebook.cells_dict),
        "cell_order" => notebook.cell_order,
        "bonds" => Dict{String,Dict{String,Any}}(
            String(key) => Dict("value" => bondvalue.value)
        for (key, bondvalue) in notebook.bonds),
    )
end

"""
For each connected client, we keep a copy of their current state. This way we know exactly which updates to send when the server-side state changes.
"""
const current_state_for_clients = WeakKeyDict{ClientSession,Any}()

"""
Update the local state of all clients connected to this notebook.
"""
function send_notebook_changes!(ðŸ™‹::ClientRequest; commentary::Any=nothing)
    notebook_dict = notebook_to_js(ðŸ™‹.notebook)
    for (_, client) in ðŸ™‹.session.connected_clients
        if client.connected_notebook !== nothing && client.connected_notebook.notebook_id == ðŸ™‹.notebook.notebook_id
            current_dict = get(current_state_for_clients, client, :empty)
            patches = Firebasey.diff(current_dict, notebook_dict)
            patches_as_dicts::Array{Dict} = patches
            current_state_for_clients[client] = deep_enough_copy(notebook_dict)

            # Make sure we do send a confirmation to the client who made the request, even without changes
            is_response = ðŸ™‹.initiator !== nothing && client == ðŸ™‹.initiator.client

            if !isempty(patches) || is_response
                response = Dict(
                    :patches => patches_as_dicts,
                    :response => is_response ? commentary : nothing
                )
                putclientupdates!(client, UpdateMessage(:notebook_diff, response, ðŸ™‹.notebook, nothing, ðŸ™‹.initiator))
            end
        end
    end
end

"Like `deepcopy`, but anything onther than `Dict` gets a shallow (reference) copy."
function deep_enough_copy(d::Dict{A,B}) where {A, B}
    Dict{A,B}(
        k => deep_enough_copy(v)
        for (k, v) in d
    )
end
deep_enough_copy(x) = x

"""
A placeholder path. The path elements that it replaced will be given to the function as arguments.
"""
struct Wildcard end

@enum Changed begin
    CodeChanged
    FileChanged
end

# to support push!(x, y...) # with y = []
Base.push!(x::Set{Changed}) = x

const no_changes = Changed[]


const effects_of_changed_state = Dict(
    "path" => function(; request::ClientRequest, patch::Firebasey.ReplacePatch)
        newpath = tamepath(patch.value)
        # SessionActions.move(request.session, request.notebook, newpath)

        if isfile(newpath)
            throw(UserError("File exists already - you need to delete the old file manually."))
        else
            move_notebook!(request.notebook, newpath)
            putplutoupdates!(request.session, clientupdate_notebook_list(request.session.notebooks))
            WorkspaceManager.cd_workspace((request.session, request.notebook), newpath)
        end
        return no_changes
    end,
    "process_status" => function(; request::ClientRequest, patch::Firebasey.ReplacePatch)
        newstatus = patch.value

        @info "Process status set by client" newstatus
    end,
    "in_temp_dir" => function(; _...) no_changes end,
    "cell_inputs" => Dict(
        Wildcard() => function(cell_id, rest...; request::ClientRequest, patch::Firebasey.JSONPatch)
            Firebasey.applypatch!(request.notebook, patch)

            if length(rest) == 0
                [CodeChanged, FileChanged]
            elseif length(rest) == 1 && Symbol(rest[1]) == :code
                [CodeChanged, FileChanged]
            else
                [FileChanged]
            end
        end,
    ),
    "cell_order" => function(; request::ClientRequest, patch::Firebasey.ReplacePatch)
        Firebasey.applypatch!(request.notebook, patch)
        [FileChanged]
    end,
    "bonds" => Dict(
        Wildcard() => function(name; request::ClientRequest, patch::Firebasey.JSONPatch)
            name = Symbol(name)
            Firebasey.applypatch!(request.notebook, patch)
            set_bond_value_reactive(
                session=request.session,
                notebook=request.notebook,
                name=name,
                is_first_value=patch isa Firebasey.AddPatch,
                run_async=true,
            )
            # [BondChanged]
            return no_changes
        end,
    )
)


responses[:update_notebook] = function response_update_notebook(ðŸ™‹::ClientRequest)
    require_notebook(ðŸ™‹)
    try
        notebook = ðŸ™‹.notebook
        patches = (Base.convert(Firebasey.JSONPatch, update) for update in ðŸ™‹.body["updates"])

        if length(patches) == 0
            send_notebook_changes!(ðŸ™‹)
            return nothing
        end

        if !haskey(current_state_for_clients, ðŸ™‹.initiator.client)
            throw(ErrorException("Updating without having a first version of the notebook??"))
        end

        # TODO Immutable ??
        for patch in patches
            Firebasey.applypatch!(current_state_for_clients[ðŸ™‹.initiator.client], patch)
        end

        changes = Set{Changed}()

        for patch in patches
            (mutator, matches, rest) = trigger_resolver(effects_of_changed_state, patch.path)
            
            current_changes = if isempty(rest) && applicable(mutator, matches...)
                mutator(matches...; request=ðŸ™‹, patch=patch)
            else
                mutator(matches..., rest...; request=ðŸ™‹, patch=patch)
            end

            push!(changes, current_changes...)
        end

        # If CodeChanged âˆˆ changes, then the client will also send a request like run_multiple_cells, which will trigger a file save _before_ running the cells.
        # In the future, we should get rid of that request, and save the file here. For now, we don't save the file here, to prevent unnecessary file IO.
        # (You can put a log in save_notebook to track how often the file is saved)
        if FileChanged âˆˆ changes && CodeChanged âˆ‰ changes
            save_notebook(notebook)
        end
    
        send_notebook_changes!(ðŸ™‹; commentary=Dict(:update_went_well => :ðŸ‘))    
    catch ex
        @error "Update notebook failed"  ðŸ™‹.body["updates"] exception=(ex, stacktrace(catch_backtrace()))
        response = Dict(
            :update_went_well => :ðŸ‘Ž,
            :why_not => sprint(showerror, ex),
            :should_i_tell_the_user => ex isa SessionActions.UserError,
        )
        send_notebook_changes!(ðŸ™‹; commentary=response)
    end
end

function trigger_resolver(anything, path, values=[])
	(value=anything, matches=values, rest=path)
end
function trigger_resolver(resolvers::Dict, path, values=[])
	if isempty(path)
		throw(BoundsError("resolver path ends at Dict with keys $(keys(resolver))"))
	end
	
	segment = first(path)
	rest = path[firstindex(path)+1:end]
	for (key, resolver) in resolvers
		if key isa Wildcard
			continue
		end
		if key == segment
			return trigger_resolver(resolver, rest, values)
		end
	end
	
	if haskey(resolvers, Wildcard())
		return trigger_resolver(resolvers[Wildcard()], rest, (values..., segment))
    else
        throw(BoundsError("failed to match path $(path), possible keys $(keys(resolver))"))
	end
end




###
# MISC RESPONSES
###

responses[:connect] = function response_connect(ðŸ™‹::ClientRequest)
    putclientupdates!(ðŸ™‹.session, ðŸ™‹.initiator, UpdateMessage(:ðŸ‘‹, Dict(
        :notebook_exists => (ðŸ™‹.notebook !== nothing),
        :options => ðŸ™‹.session.options,
        :version_info => Dict(
            :pluto => PLUTO_VERSION_STR,
            :julia => JULIA_VERSION_STR,
        ),
    ), nothing, nothing, ðŸ™‹.initiator))
end

responses[:ping] = function response_ping(ðŸ™‹::ClientRequest)
    putclientupdates!(ðŸ™‹.session, ðŸ™‹.initiator, UpdateMessage(:pong, Dict(), nothing, nothing, ðŸ™‹.initiator))
end

responses[:reset_shared_state] = function response_reset_shared_state(ðŸ™‹::ClientRequest)
    delete!(current_state_for_clients, ðŸ™‹.initiator.client)
    send_notebook_changes!(ðŸ™‹; commentary=Dict(:from_reset =>  true))
end

responses[:run_multiple_cells] = function response_run_multiple_cells(ðŸ™‹::ClientRequest)
    require_notebook(ðŸ™‹)
    uuids = UUID.(ðŸ™‹.body["cells"])
    cells = map(uuids) do uuid
        ðŸ™‹.notebook.cells_dict[uuid]
    end

    if will_run_code(ðŸ™‹.notebook)
        foreach(c -> c.queued = true, cells)
        send_notebook_changes!(ðŸ™‹)
    end
    
    # save=true fixes the issue where "Submit all changes" or `Ctrl+S` has no effect.
    update_save_run!(ðŸ™‹.session, ðŸ™‹.notebook, cells; run_async=true, save=true)
end

responses[:get_all_notebooks] = function response_get_all_notebooks(ðŸ™‹::ClientRequest)
    putplutoupdates!(ðŸ™‹.session, clientupdate_notebook_list(ðŸ™‹.session.notebooks, initiator=ðŸ™‹.initiator))
end

responses[:interrupt_all] = function response_interrupt_all(ðŸ™‹::ClientRequest)
    require_notebook(ðŸ™‹)

    session_notebook = (ðŸ™‹.session, ðŸ™‹.notebook)
    workspace = WorkspaceManager.get_workspace(session_notebook)

    already_interrupting = ðŸ™‹.notebook.wants_to_interrupt
    anything_running = !isready(workspace.dowork_token)
    if !already_interrupting && anything_running
        ðŸ™‹.notebook.wants_to_interrupt = true
        WorkspaceManager.interrupt_workspace(session_notebook)
    end
    # TODO: notify user whether interrupt was successful
end

responses[:shutdown_notebook] = function response_shutdown_notebook(ðŸ™‹::ClientRequest)
    require_notebook(ðŸ™‹)
    SessionActions.shutdown(ðŸ™‹.session, ðŸ™‹.notebook; keep_in_session=ðŸ™‹.body["keep_in_session"])
end

without_initiator(ðŸ™‹::ClientRequest) = ClientRequest(session=ðŸ™‹.session, notebook=ðŸ™‹.notebook)

responses[:restart_process] = function response_restrart_process(ðŸ™‹::ClientRequest)
    require_notebook(ðŸ™‹)
    
    if ðŸ™‹.notebook.process_status != ProcessStatus.waiting_to_restart
        ðŸ™‹.notebook.process_status = ProcessStatus.waiting_to_restart
        send_notebook_changes!(ðŸ™‹ |> without_initiator)

        SessionActions.shutdown(ðŸ™‹.session, ðŸ™‹.notebook; keep_in_session=true, async=true)

        ðŸ™‹.notebook.process_status = ProcessStatus.starting
        send_notebook_changes!(ðŸ™‹ |> without_initiator)

        update_save_run!(ðŸ™‹.session, ðŸ™‹.notebook, ðŸ™‹.notebook.cells; run_async=true, save=true)
    end
end


responses[:reshow_cell] = function response_reshow_cell(ðŸ™‹::ClientRequest)
    require_notebook(ðŸ™‹)
    cell = let
        cell_id = UUID(ðŸ™‹.body["cell_id"])
        ðŸ™‹.notebook.cells_dict[cell_id]
    end
    run = WorkspaceManager.format_fetch_in_workspace((ðŸ™‹.session, ðŸ™‹.notebook), cell.cell_id, ends_with_semicolon(cell.code), (parse(PlutoRunner.ObjectID, ðŸ™‹.body["objectid"], base=16), convert(Int64, ðŸ™‹.body["dim"])))
    set_output!(cell, run, ExprAnalysisCache(ðŸ™‹.notebook, cell))
    # send to all clients, why not
    send_notebook_changes!(ðŸ™‹ |> without_initiator)
end



###
# HANDLE NEW BOND VALUES
###

function set_bond_value_reactive(; session::ServerSession, notebook::Notebook, name::Symbol, is_first_value::Bool=false, kwargs...)
    bound_sym = name
    new_value = notebook.bonds[name].value

    variable_exists = is_assigned_anywhere(notebook, notebook.topology, bound_sym)
    if !variable_exists
        # a bond was set while the cell is in limbo state
        # we don't need to do anything
        return
    end

    # TODO: Not checking for any dependents now
    # any_dependents = is_referenced_anywhere(notebook, notebook.topology, bound_sym)

    # fix for https://github.com/fonsp/Pluto.jl/issues/275
    # if `Base.get` was defined to give an initial value (read more about this in the Interactivity sample notebook), then we want to skip the first value sent back from the bond. (if `Base.get` was not defined, then the variable has value `missing`)
    # Check if the variable does not already have that value.
    # because if the initial value is already set, then we don't want to run dependent cells again.
    eq_tester = :(try !ismissing($bound_sym) && ($bound_sym == $new_value) catch; false end) # not just a === comparison because JS might send back the same value but with a different type (Float64 becomes Int64 in JS when it's an integer.)
    if is_first_value && WorkspaceManager.eval_fetch_in_workspace((session, notebook), eq_tester)
        return
    end
        
    function custom_deletion_hook((session, notebook)::Tuple{ServerSession,Notebook}, to_delete_vars::Set{Symbol}, funcs_to_delete::Set{Tuple{UUID,FunctionName}}, to_reimport::Set{Expr}; to_run::AbstractVector{Cell})
        to_delete_vars = Set([to_delete_vars..., bound_sym]) # also delete the bound symbol
        WorkspaceManager.delete_vars((session, notebook), to_delete_vars, funcs_to_delete, to_reimport)
        WorkspaceManager.eval_in_workspace((session, notebook), :($(bound_sym) = $(new_value)))
    end
    to_reeval = where_referenced(notebook, notebook.topology, Set{Symbol}([bound_sym]))

    update_save_run!(session, notebook, to_reeval; deletion_hook=custom_deletion_hook, save=false, persist_js_state=true, kwargs...)
end

responses[:write_file] = function (ðŸ™‹::ClientRequest)
    path = ðŸ™‹.notebook.path
    reldir = "$(path |> basename).assets"
    dir = joinpath(path |> dirname, reldir)
    file_noext = reduce(*, split(ðŸ™‹.body["name"], ".")[1:end - 1])
    extension = split(ðŸ™‹.body["name"], ".")[end]
    save_path = numbered_until_new(joinpath(dir, file_noext); sep=" ", suffix=".$(extension)", create_file=false)

    if !ispath(dir)
        mkpath(dir)
    end
    success = try
        io = open(save_path, "w")
        write(io, ðŸ™‹.body["file"])
        close(io)
        true
    catch e
        false
    end

    code = template_code(basename(save_path), reldir, ðŸ™‹.body["file"])

    msg = UpdateMessage(:write_file_reply, 
        Dict(
            :success => success,
            :code => code
        ), ðŸ™‹.notebook, nothing, ðŸ™‹.initiator)

    putclientupdates!(ðŸ™‹.session, ðŸ™‹.initiator, msg)
end

# helpers

function template_code(filename, directory, iofilecontents)
    path = """joinpath(split(@__FILE__, '#')[1] * ".assets", "$(filename)")"""
    extension = split(filename, ".")[end]
    varname = replace(basename(path), r"[\"\-,\.#@!\%\s+\;()\$&*\[\]\{\}'^]" => "")

    if extension âˆˆ ["jpg", "jpeg", "png", "svg", "webp", "tiff", "bmp", "gif", "wav", "aac", "mp3", "mpeg", "mp4", "webm", "ogg"]
        req_code = "import PlutoUI"
        code = """$(extension)_$(varname) = let
    $(req_code)
    PlutoUI.LocalResource($(path))
end"""

    elseif extension âˆˆ ["txt", "text"]
        code = """txt_$(varname) = let
    $(varname) = open($(path))
    read($(varname), String)
end"""

    elseif extension âˆˆ ["jl"]
        io = IOBuffer();
        write(io, iofilecontents)
        code = String(take!(io))

    elseif is_extension_supported(extension)
        code = get_example_code(directory, filename)

    else
        code = missing
    end
end
