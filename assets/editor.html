<!DOCTYPE html>
<html lang="en">

<head>
	<meta name="viewport" content="width=device-width, user-scalable=no" />
	<title>âš¡ Saturn.jl âš¡</title>
	<meta charset="utf-8" />
	<script>
		console.log("Saturn.jl, by Fons van der Plas (https://github.com/fonsp) and MikoÅ‚aj Bochenski (https://github.com/malyvsen) ðŸŒˆ");
	</script>
	<meta name="author" content="Fons van der Plas; MikoÅ‚aj Bochenski" />
	<link rel="license" href="https://github.com/fonsp/Saturn.jl/blob/master/LICENSE" />
	<meta name="theme-color" content="#000000" />
	<meta name="description" content="Saturn.jl notebook" />
	<link href="https://fonts.googleapis.com/css?family=Roboto+Mono:300,300i,400,400i,500,500i&display=swap&subset=cyrillic,cyrillic-ext,greek,greek-ext,latin-ext,vietnamese" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Roboto+Slab:100,200,300,400,500,600,700,800,900&display=swap&subset=cyrillic,cyrillic-ext,greek,greek-ext,latin-ext,vietnamese" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Merriweather:300,300i,400,400i,700,700i,900,900i&display=swap&subset=cyrillic,cyrillic-ext,latin-ext,vietnamese" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i&display=swap&subset=cyrillic,cyrillic-ext,greek,greek-ext,latin-ext,vietnamese" rel="stylesheet">


	<style>
		/* GENERAL PAGE LAYOUT */

		body {
			margin: 0px;
		}

		/* more sensible defaults for html tags: */
		/* (can be overriden by custom style) */
		h1,
		h2,
		h3,
		h4,
		h5,
		h6 {
			font-family: sans-serif;
			margin-block-start: 1em;
			margin-block-end: 0em;
		}

		h1 {
			font-size: 2.2em;
			border-bottom: 3px solid rgba(0, 0, 0, .15);
		}

		h2 {
			font-size: 1.8em;
			border-bottom: 2px dotted rgba(0, 0, 0, .15);
		}

		h3 {
			font-size: 1.6em;
			/* border-bottom: 2px dotted rgba(0,0,0,.15); */
		}

		h4 {
			font-size: 1.4em;
		}

		h5 {
			font-size: 1.2em;
		}

		h6 {
			font-size: 1em;
		}

		p {
			margin-block-start: .5em;
		}

		html,
		body {
			height: 100%;
		}

		main {
			min-height: calc(100% - 73px - 60px);
			margin: 0 auto;
			max-width: 960px;
			align-content: center;
			padding: 8px;
		}

		/* HEADER */

		header {
			letter-spacing: 2px;
			background: hsla(0, 100%, 100%, 80%);
			width: 100%;
			height: 70px;
			overflow: hidden;
			color: black;
			/* white-space: nowrap; */
			/*font-weight: normal;*/
			font-family: 'Ubuntu Mono', monospace;
			border-bottom: solid 1px rgba(0, 0, 0, .1);
		}

		#logocontainer {
			margin: 0 auto;
			max-width: 960px;
			padding-top: 14px;
			padding-left: 20px;
			padding-bottom: 0px;
		}

		#logocontainer img {
			margin-bottom: -9px;
			margin-right: 15px;
			filter: invert(100%);
			-webkit-filter: invert(100%);
			/* Alttext: */
			color: black;
			/* should be black beacuse we are reversing its color */
			font-family: 'Courgette', sans-serif;
			font-weight: bold !important;
			font-style: normal;
		}

		#logocontainer h1 {
			font-weight: 700;
			font-size: 30px;
			display: inline;
			border-bottom: none;
		}

		#logocontainer h2 {
			display: inline;
			border-bottom: none;
		}

		#logocontainer h1>span {
			font-weight: 400;
		}

		#printernametitle {
			opacity: .6;
			font-style: normal;
			font-size: 25px;
		}

		header.disconnected {
			background-color: rgba(255, 100, 0, .3);
		}

		.disconnected>#logocontainer:after {
			content: "NOT CONNECTED";
			text-align: right;
			float: right;
			padding: 12px;
		}

		/* MAIN */

		cell {
			display: block;
		}

		celloutput {
			display: block;
			min-height: 25px;
			padding-left: 10px;
			padding-right: 10px;
			overflow: auto;
		}

		code {
			font-family: monospace;
		}

		cell.error>code {
			color: darkred;
		}

		.CodeMirror {
			height: auto !important;
			width: 100%;
			z-index: 2;
		}

		.CodeMirror-scroll {
			min-height: 0px;
		}

		.CodeMirror-empty {
			color:rgba(0, 0, 0, .15);
		}

		cell.code-folded>cellinput {
			display: none;
		}

		trafficlight {
			pointer-events: none;
			width: 4px;
			position: absolute;
			left: -4px;
			top: 0px;
			bottom: 0px;
		}

		/* In order of severity: */

		cell.dependent>trafficlight {
			background: lightblue;
		}

		cell.warning>trafficlight {
			background: orange;
		}


		cell.error>trafficlight {
			background: red;
		}

		clickshoulder {
			position: absolute;
			top: 0px;
			bottom: 0px;
			width: 2000px;
			left: -2000px;
			cursor: pointer;
		}

		clickshoulder:hover {
			background: rgba(0, 0, 0, .05);
		}

		cell > button > span {
			pointer-events: none;
		}

		footer {
			width: 100%;
			height: 30px;
			font-family: monospace;
			margin-top: 30px;
		}

		footer a {
			color: black;
			opacity: .6;
			font-weight: 700;
			;
		}

		#info {
			max-width: 9400px;
			margin: 0 auto;
			text-align: right;
			padding: 5px;
		}
	</style>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.0/codemirror.min.css">
	<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.0/theme/paraiso-light.min.css" /> -->
	<link rel="stylesheet" href="./light.css" />
	<link rel="stylesheet" href="/customstyle.css" />

	<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.0/codemirror.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.0/mode/julia/julia.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.0/addon/display/placeholder.min.js"></script>
</head>

<body>
	<header>
		<div id="logocontainer">
			<h1>
				SATURN<span>.jl</span></h1>
			<h2>
				<span id="printernametitle">/editor</span></h2>
		</div>
	</header>

	<main>
		<notebook>
		</notebook>
		<template id="celltemplate">
			<cell>
				<clickshoulder></clickshoulder>
				<trafficlight></trafficlight>
				<button class="addcell before"><span>add +</span></button>
				<button class="deletecell"><span>delete X</span></button>
				<celloutput tabindex="1"></celloutput>
				<cellinput></cellinput>
				<button class="addcell after"><span>add +</span></button>
			</cell>
		</template>
	</main>

	<footer>
		<div id="info">
			<a href="https://github.com/fonsp/Saturn.jl">Saturn.jl</a>, by <a href="https://github.com/fonsp" rel="author">fonsp</a> and <a href="https://github.com/malyvsen" rel="author">malyvsen</a>
		</div>
	</footer>

	<script>
		document.addEventListener("DOMContentLoaded", () => {
			notebookName = "test_notebook.jl"
			document.querySelector("#printernametitle").innerText = "/" + notebookName;

			function startDisconnectedBanner() {
				document.querySelector("header").classList.add("disconnected")
				setTimeout(() => {
					ping(() => {
						document.querySelector("header").classList.remove("disconnected")
					}, startDisconnectedBanner)
				}, 1000)
			}

			window.localCells = {}
			window.codeMirrors = {}

			function createCodeMirrorInsideCell(cellNode, code) {
				var editor = CodeMirror((elt) => {
					cellNode.querySelector("cellinput").appendChild(elt)
				}, {
					value: code,
					lineNumbers: true,
					mode: "julia",
					lineWrapping: true,
					lineNumberFormatter: function (i) {
						return "â‹…"
					},
					// theme: "paraiso-light",
					viewportMargin: Infinity,
					placeholder: "Enter cell code...",
				});

				window.codeMirrors[cellNode.id] = editor
				//editor.setOption("readOnly", true);

				editor.setOption("extraKeys", {
					"Ctrl-Enter": () => changeRemoteCell(cellNode.id)
				});
			}

			function updateLocalCellOutput(cellNode, mime, output, errormessage) {
				console.log(mime)
				if (errormessage) {
					cellNode.querySelector("celloutput").innerHTML = "<pre><code></code></pre>"
					cellNode.querySelector("celloutput").querySelector("code").innerText = errormessage
					cellNode.classList.add("error")
				} else {
					cellNode.classList.remove("error")
					if (mime == "text/html") {
						// from https://stackoverflow.com/a/26716182

						cellNode.querySelector("celloutput").innerHTML = output

						// to execute all scripts in the output html:
						try {
							var scripts = Array.prototype.slice.call(cellNode.querySelector("celloutput").getElementsByTagName("script"))
							for (var i = 0; i < scripts.length; i++) {
								if (scripts[i].src != "") {
									if (!Array.prototype.map.call(document.head.querySelectorAll("script"), s => s.src).includes(scripts[i])) {
										var tag = document.createElement("script")
										tag.src = scripts[i].src
										document.head.appendChild(tag)
									}
								}
								else {
									eval(scripts[i].innerHTML)
								}
							}
						} catch (err) {
							console.log("Couldn't execute all scripts:")
							console.log(err)
							// TODO: relay to user
							// might be wise to wait after adding scripts to head
							//
						}
					} else {
						cellNode.querySelector("celloutput").innerHTML = "<pre><code></code></pre>"
						cellNode.querySelector("celloutput").querySelector("code").innerText = output
					}
				}
			}

			cellTemplate = document.querySelector("#celltemplate").content.firstElementChild
			notebookNode = document.querySelector("notebook")
			window.notebookNode = notebookNode

			function indexOfLocalCell(cellNode) {
				// .indexOf doesn't work on HTMLCollection
				for (var i = 0; i < notebookNode.children.length; i++) {
					if (notebookNode.children[i].id == cellNode.id) {
						return i
					}
				}
			}

			function createLocalCell(newIndex, uuid, code) {
				var newCellNode = cellTemplate.cloneNode(true)
				newCellNode.id = uuid

				window.localCells[uuid] = newCellNode


				if (notebookNode.children.length == newIndex) {
					notebookNode.appendChild(newCellNode)
				} else if (notebookNode.children.length > newIndex) {
					notebookNode.insertBefore(newCellNode, notebookNode.children[newIndex])
				} else {
					console.error("Tried to insert cell at illegal position! Notebook order might be messed up!")
					notebookNode.appendChild(newCellNode)
				}

				// EVENT LISTENERS FOR CLICKY THINGS

				newCellNode.querySelector("clickshoulder").onclick = (e) => {
					e.target.parentElement.classList.toggle("code-folded")
					// You may not fold code if the output is empty (it would be confusing)
					if (!e.target.parentElement.querySelector("celloutput").innerHTML) {
						e.target.parentElement.classList.remove("code-folded")
					}
				}


				newCellNode.querySelector(".addcell.before").onclick = (e) => {
					requestNewRemoteCell(indexOfLocalCell(e.target.parentElement))
				}
				newCellNode.querySelector(".addcell.after").onclick = (e) => {
					requestNewRemoteCell(indexOfLocalCell(e.target.parentElement) + 1)
				}
				newCellNode.querySelector(".deletecell").onclick = (e) => {
					console.log(e.target.parentElement)
					console.log(e)
					requestDeleteRemoteCell(e.target.parentElement.id)
				}

				createCodeMirrorInsideCell(newCellNode, code)
				//updateLocalCellOutput(newCellNode, mime, output, errormessage)
				return newCellNode
			}

			function deleteLocalCell(cellNode) {
				// TODO: event listeners? gc?
				uuid = cellNode.id
				try {
					delete window.codeMirrors[uuid]
				} catch (err) { }
				try {
					delete window.localCells[uuid]
				} catch (err) { }

				cellNode.remove()
			}

			function deleteAllLocalCells() {
				for (var uuid in window.localCells) {
					deleteLocalCell(window.localCells[uuid])
				}
			}

			// This is kind of overkill
			function ping(onSucces, onFailure) {
				fetch("/ping", {
					method: 'GET',
					cache: 'no-cache',
					headers: {
						'Content-Type': 'application/json',
					},
					redirect: 'follow',
					referrerPolicy: 'no-referrer',
					//body: "hiiiii"
				}).then((response) => {
					return response.json()
				}).then((response) => {
					if (response == "OK!") {
						onSucces(response)
					} else {
						onFailure(response)
					}
				}).catch(onFailure)
			}

			function reloadAllCells(onFailure, onSucces) {
				ping(() => {
					// We have a connection!

					fetch("/getallcells", {
						method: 'GET',
						cache: 'no-cache',
						headers: {
							'Content-Type': 'application/json',
						},
						redirect: 'follow',
						referrerPolicy: 'no-referrer',
						//body: "hiiiii"
					}).then((response) => {
						return response.json()
					}).then((remoteCells) => {
						console.log("Remote cells loaded")
						console.log(remoteCells)

						for (var cellIndex in remoteCells) {
							remoteCell = remoteCells[cellIndex]
							cellElement = createLocalCell(cellIndex, remoteCell.uuid, remoteCell.code)
							// if ((remoteCell.mime && remoteCell.output) || remoteCell.errormessage) {
							// 	updateLocalCellOutput(cellElement, remoteCell.mime, remoteCell.output, remoteCell.errormessage)
							// }
						}

						onSucces()
					}).catch(onFailure)
				}, console.warn)
			}

			function changeRemoteCell(uuid) {
				var onFailure = (response) => {
					console.warn("Failed to update cell!")
					console.log(response)

					startDisconnectedBanner()
				}
				newCode = window.codeMirrors[uuid].getValue()
				fetch("/changecell", {
					method: 'PUT',
					cache: 'no-cache',
					headers: {
						'Content-Type': 'application/json'
					},
					redirect: 'follow',
					referrerPolicy: 'no-referrer',
					body: JSON.stringify({ "uuid": uuid, "code": newCode }),
				}).then((response) => {
					if (response.status == 200) {
						console.log("Cell updated.")
					} else {
						onFailure(response)
					}
				}).catch(onFailure)
			}

			function runUpdateLoop() {
				console.log("run update loop")
				var onFailure = (response) => {
					console.warn("Failed to get updates!")
					console.log(response)

					document.querySelector("header").classList.add("disconnected")


					setTimeout(() => {
						ping(() => {
							document.querySelector("header").classList.remove("disconnected")
							runUpdateLoop()
						}, onFailure)
					}, 1000)
				}

				fetch("/nextcellupdate", {
					method: 'GET',
					cache: 'no-cache',
					redirect: 'follow',
					referrerPolicy: 'no-referrer',
				}).then((response) => {
					console.log("update response received")
					console.log(response)
					if (response.status == 200) {
						response.json().then((update) => {
							// UPDATE RECEIVED
							console.log("output deserialized")
							console.log(update)

							var message = update.message

							switch (update.type) {
								case "update_output":
									updateLocalCellOutput(window.localCells[message.uuid], message.mime, message.output, message.errormessage)
									break
								case "cell_added":
									createLocalCell(message.index, message.uuid, "")
									break
								case "cell_deleted":
									// TODO: catch exception
									var toDelete = window.localCells[message.uuid]
									deleteLocalCell(toDelete)
									break
								case "cell_moved":
									// TODO: handle move!

									break
								default:
									console.error("Received unknown update type!")
									alert("Something went wrong ðŸ™ˆ\n Try refreshing the page")
									break
							}
							//TODO: animation âœ¨

							runUpdateLoop()
						})
					} else if (response.status == 204) {
						runUpdateLoop()
					} else {
						onFailure(response)
					}
				}).catch(onFailure)
			}

			function requestNewRemoteCell(newIndex) {
				var onFailure = (response) => {
					console.warn("Failed to request remote cell!")
					console.log(response)

					startDisconnectedBanner()
				}
				fetch("/addcell", {
					method: 'POST',
					cache: 'no-cache',
					headers: {
						'Content-Type': 'application/json'
					},
					redirect: 'follow',
					referrerPolicy: 'no-referrer',
					body: JSON.stringify({ "index": newIndex }),
				}).then((response) => {
					if (response.status == 200) {
						console.log("Cell added.")
					} else {
						onFailure(response)
					}
				}).catch(onFailure)
			}

			function requestDeleteRemoteCell(uuid) {
				var onFailure = (response) => {
					console.warn("Failed to delete remote cell!")
					console.log(response)

					startDisconnectedBanner()
				}
				fetch("/deletecell", {
					method: 'DELETE',
					cache: 'no-cache',
					headers: {
						'Content-Type': 'application/json'
					},
					redirect: 'follow',
					referrerPolicy: 'no-referrer',
					body: JSON.stringify({ "uuid": uuid }),
				}).then((response) => {
					if (response.status == 200) {
						console.log("Cell deleted.")
					} else {
						onFailure(response)
					}
				}).catch(onFailure)
			}
			ping(console.log, console.warn)
			reloadAllCells(console.warn, runUpdateLoop)

			if ("fonts" in document) {
				document.fonts.ready.then(function () {
					console.log("fonts loaded");
					for (var uuid in window.codeMirrors) {
						window.codeMirrors[uuid].refresh()
					}
				});
			}

			// TODO: reconnect with a delay if the last request went poorly
			// this would avoid hanging UI when the connection is lost maybe?
			// implemented, but untested

			// TODO: check cell order every now and then?
			// or do ___maths___ to make sure that it never gets messed up




			window.reloadAllCells = reloadAllCells
			window.ping = ping


			//editor.on("change", window.preview);
			window.fakeCells = () => {
				var last;
				last = createLocalCell(0, "0", "100*x + y")
				updateLocalCellOutput(last, "text/plain", "100*x + y", "")
				last = createLocalCell(1, "0", "x = 1 + 1")
				updateLocalCellOutput(last, "text/plain", "x = 1 + 1", "")
				last = createLocalCell(2, "0", "y = x * 2")
				updateLocalCellOutput(last, "text/plain", "y = x * 2", "")
				last = createLocalCell(3, "0", "html\"<h1>Hoi!</h1>\n<p>My name is <em>kiki</em></p>\"")
				updateLocalCellOutput(last, "text/html", "<h1>Hoi!</h1>\n<p>My name is <em>kiki</em></p>", "")
				last = createLocalCell(4, "0", "using Markdown; md\"# CzeÅ›Ä‡!\nMy name is **baba** and I like \$maths\$\n\n_(Markdown -> HTML is for free, for LaTeX we need to pre-/post-process the HTML, and import a latex-js lib)_\"")
				updateLocalCellOutput(last, "text/html", "using Markdown; md\"# CzeÅ›Ä‡!\nMy name is **baba** and I like \$maths\$\n\n_(Markdown -> HTML is for free, for LaTeX we need to pre-/post-process the HTML, and import a latex-js lib)_\"", "")

			}

			if (document.location.protocol == "file:") {
				window.fakeCells()
			}
		});
	</script>
	<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/dot/1.1.3/doT.min.js" integrity="sha256-0Mj4wysSsxKrjqVsgnOgOeRZbPreFi/T3+zb+cyR7Jw=" crossorigin="anonymous"></script>-->
</body>

</html>